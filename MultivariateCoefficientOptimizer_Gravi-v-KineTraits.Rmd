---
title: "MultivariateCoefficientOptimizer_Gravi-v-KineTraits"
author: "Ashley Henry, Nathan Miller"
date: "11/17/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(plotly)
library(tidyverse)
library(readr)
library(rowr)
require(reshape2)
library(dplyr)
library(pracma)
library(data.table)
library(qtl2)
```

```{r metric-function}

metric <- function(mappedList1, mappedList2){
  # Does correlation
  correlation = cor(mappedList1, mappedList2, use = "complete.obs")
  return(correlation)
}

# Try this out:
# mappedList1 = runif(10)
# mappedList2 = runif(10)
# metric(mappedList1, mappedList2)
```

```{r predictor-function}

predictor <- function(M, v){
  v = v / norm(as.matrix(v))
  predicted = M%*%v
  return(predicted)
}

# Try this out:
# pmat = matrix(c(1:4), ncol = 4, nrow = 162)
# pvec = c(1, 1, 1, 1)
# ppre = predictor(pmat, pvec)
# 
# smat = matrix(c(1:2), ncol = 2, nrow = 162)
# svec = c(1, 1)
# spre = predictor(smat, svec)
```

```{r QTLMapping-function}
# Ash Note: This works for CT being there, but we need to redo this so that we enter in our own phenotype data
## That way we don't have to load it into the .json file
## So, make a genotype file with the marker data (& location...?)

mapper <- function(data_in_csv, ct){
  # Inserted pieces of QTLCode.R (see QTLCode.R for annotations!)
  # Have it return peaks from 0 permutations to test
  
  g1 <- do.call("cbind", ct$geno) 
  map <- insert_pseudomarkers(ct$gmap, step = 2.5, stepwidth = "max")
  pr <- calc_genoprob(ct, map, error_prob = 0.002)
  m1 <- maxmarg(pr)
  xo1 <- count_xo(m1) 
  k_loco <- calc_kinship(pr, "loco") 
  x = dim(ct$pheno)[2]
  out <- scan1(pr, ct$pheno[,c(1:x)], k_loco, cores = 4)
  # print(out)
  nperm = 1000 # changed n_perm = 10000 from 1000 (5.9.2021)
  operm <- scan1perm(pr[,1:5], ct$pheno[,c(1:x)], k_loco[1:5], addcovar = NULL,
                   Xcovar = NULL, intcovar = NULL, weights = NULL, reml = TRUE,
                   model = "normal", n_perm = nperm, perm_Xsp = FALSE,
                   perm_strata = NULL, chr_lengths = NULL, cores = 4)

  sig <- summary(operm, alpha = c(0.05)) # Need this? 
  return(out)
}

## Try this out & plot LOD scores:
# setwd("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL")
# CT <- read_cross2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/CvixLer.working.json")
# CT
# CT$pheno <- tipAngle # change phenotype data for mapper()
# map = mapper(pheno, CT)
# x_axis = c(1:340)
# plot(x_axis, map[,1]) # plot 1st column of LOD scores by marker

```

```{r qtl-function-no-CT-loading_IN-PROGRESS}
#######################################################
##### Testing qtl function so can use without CT ######
# Gave up on this 2021-11-29 b/c above function works #
#######################################################

CT <- read_cross2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/CvixLer.working.json")
geno <- read_csv2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/ALFP_geno.csv")
gmap <- read_csv("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/ALFP_gmap.csv")
pmap <- read_csv2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/ALFP_geno.csv")
# pheno = "phenotypes by RIL" #(2021_11_22_growthCurveDescriptors_Averaged-pos-to-3000.csv)
pheno1 <- runif(162)
pheno2 <- runif(162)
RIL <- c(1:162)
pheno <- matrix(data = cbind(RIL, pheno2), nrow = 162, ncol = 2) # phenotype (try 1st w/ a random set of numbers & get no peaks)
# If matrix() ->
# Note:
##  "alleles": ["L", "C"], "genotypes": {"L": 1, "C": 2}

mapperTMP <- function(gmap, genomap, pheno, CT){
  # Inserted pieces of QTLCode.R (see QTLCode.R for annotations!)
  # Have it return peaks from 0 permutations

  g1 <- do.call("cbind", geno)
  map <- insert_pseudomarkers(CT$gmap, step = 2.5, stepwidth = "max")
  pr <- calc_genoprob(CT, map, error_prob = 0.002)
  m1 <- maxmarg(pr)
  xo1 <- count_xo(m1)
  k_loco <- calc_kinship(pr, "loco")
  out <- scan1(pr, pheno, k_loco, cores = 4)
  print(out)
  nperm = 1 # changed n_perm = 10000 from 1000 (5.9.2021)
  operm <- scan1perm(pr[,1:5], pheno[,c(1)], k_loco[1:5], addcovar = NULL,
                   Xcovar = NULL, intcovar = NULL, weights = NULL, reml = TRUE,
                   model = "normal", n_perm = nperm, perm_Xsp = FALSE,
                   perm_strata = NULL, chr_lengths = NULL, cores = 4)

  sig <- summary(operm, alpha = c(0.05)) # Need this?
  return(out)
}

map = mapperTMP(gmap, genomap, pheno, CT)
x = c(1:340)
plot(x,map)
```

```{r putting-it-all-together}
REGR = read_csv("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/2021_04_18_growthCurveDescriptors_Averaged-FINAL.csv")
REGR = data.matrix(REGR)
tipAngle = read_csv("~/Desktop/GravitropismAssay/TipAngle-Parameters-KinematicTraits_Data/2021-11-30_tipAngle_PCScores.csv")
tipAngle = data.matrix(tipAngle)

# Overall goal is to calculate the sum of correlations below: 
## Note: Test alpha as c(1,1,1,1) (check by summing row 1); test alpha with c(0.25, 0.25, 0.25, 0.25) (check by taking average of row 1)
# metric(predictor(REGR,c(0.25,0.25,0.25,0.25)), predictor(tipAngle, beta)) + metric(mapper(G,predictor(REGR, alpha)), mapper(G,predictor(tipAngle, beta)))

# T1 for predicting and calculating correlation
T1 <- function(s){
  alpha = s[1:4]
  beta = s[5:6] # specify this as "end of s" later
  A = metric(predictor(REGR, alpha), predictor(tipAngle, beta))
  A = as.vector(A)
}

T1(c(1,1,1,1,2,2)) # need 6 because we have 6 total phenotypes (4 kine traits + 2 PC scores of gravi data)
xSol1 = fminsearch(T1, runif(6), minimize = FALSE, maxiter = 100) # with min = FALSE, it searches for maximum

# T2 for mapping and calculating correlation
setwd("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL")
CT <- read_cross2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/CvixLer.working.json")
CT

T2 <- function(p){
  alpha = p[1:4]
  beta  = p[5:7] # specify this as "end of p" later
  
  # Below is original when had mappers together & didn't include both phenotypes  
  # B = metric(mapper(G,predictor(REGR, alpha)), mapper(G,predictor(tipAngle, beta)))

  # Load regr and tip angles
  ct   <- read_cross2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/CvixLer.working.json")
  regr <- read_csv("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/2021_04_18_growthCurveDescriptors_Averaged-FINAL.csv")
  tagl <- read_csv("~/Desktop/GravitropismAssay/TipAngle-Parameters-KinematicTraits_Data/2021-11-30_tipAngle_PCScores.csv")
  regr = data.matrix(regr)
  tagl = data.matrix(tagl)

  
  Z = metric(predictor(REGR, alpha), predictor(tipAngle, beta))
  Z = as.vector(Z)
  
  # Phenotype = REGR for 1st mapper
  ct$pheno <- regr
  A = mapper(predictor(regr, alpha), ct)
  
  # Phenotype = tipAngle for 2nd mapper
  ct$pheno <- tagl
  B = mapper(predictor(tagl, beta), ct)
  C = metric(A, B)
  C = as.vector(C)
  D = C + Z
  print(D)
}

xSol2 = fminsearch(T2, runif(6), minimize = FALSE, maxiter = 100)
pp    = xSol2$xmin
optA  = pp[1:4]
optB  = pp[5:7]

optAA  = predictor(REGR, optA)
optBB  = predictor(tipAngle, optB)

plot(optAA, optBB)
data = data.frame(cbind(optAA, optBB))
ggplot(data, aes(optAA)) +
  geom_point(aes(y=optBB), colour = "blue")

optCC = mapper(predictor(REGR, optA), CT)
optDD = mapper(predictor(tipAngle, optB), CT)

x_axis = c(1:340)
plot(x_axis, optCC[,1]) # plot 1st column of LOD scores by marker

data2 = data.frame(cbind(x_axis, optCC[,1], optDD[,1]))
ggplot(data2, aes(x_axis)) + 
  # geom_point(aes(y = optCC[,1]), colour = "red") +
  geom_point(aes(y = optDD[,1]), colour = "blue")

```

```{r TO-DO-LIST}
### TO DO LIST | Made 2021-11-30 ###
## Need to save 2 different LOD score datasets!!!
# need loop to have it start at 100 random start values & pick the best solution
## Why is the convergence 0? 
## Check out output to understand it (tolerance, maxiter, max etc.)

## After chatting briefly with Nathan on 20 December 2021, this is my next step:
# Use predictor to get "new" values for kine traits (new alphas) & "new" values for PC of tipAngles (new betas)
# Scatterplot these new values & compare to scatterplots of original kine traits & PCs
```

``` {r actually-putting-it-all-together}
# T3 combines the 2 datasets below to see which "recipe" gives the best correlation between these:
## raw REGR & tipAngle PC scores data
REGR = read_csv("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/2021_04_18_growthCurveDescriptors_Averaged-FINAL.csv")
REGR = data.matrix(REGR)
tipAngle = read_csv("~/Desktop/GravitropismAssay/TipAngle-Parameters-KinematicTraits_Data/2021-11-30_tipAngle_PCScores.csv")
tipAngle = data.matrix(tipAngle)

T3 <- function(s){
  params = s[1:4]
  scrs   = s[5:7]
  
  Pc = predictor(REGR, params)
  Sc = predictor(tipAngle, scrs)
  p  = as.vector(metric(Pc, Sc))
}

pinit = runif(7)
topt  = fminsearch(T3, pinit, minimize = FALSE, maxiter = 10000)
pp    = topt$xmin
optJ  = pp[1:4]
optK  = pp[5:7]

# Transform REGR & tipAngle data by the "recipe" from fminsearch()
optJJ = predictor(REGR, optJ)
optKK = predictor(tipAngle, optK)
copt  = metric(optJJ,optKK)

# Plotting new REGR & tipAngle data to visualize correlation
ttl  = sprintf("Transformed Tip Angle PCs and REGR Traits Data [corr = %f]", copt)
data = data.frame(cbind(optJJ, optKK))
ggplot(data, aes(x = optJJ, y = optKK)) +
  geom_point(aes(y = optKK), colour = "blue") +
  xlab("REGR Trait Data") +
  ylab("Tip Angle PC Scores Data") +
  ggtitle(ttl) +
  stat_summary(fun.data = mean_cl_normal) + 
  geom_smooth(method = 'lm') +
  theme_bw()

```


```{r something-else}
metric(optJJ, optKK) # -0.04825338
metric(REGR[,1], tipAngle[,1]) # 0.2065649
metric(REGR[,4], tipAngle[,1]) # 0.2065649


# T4 combines the 2 datasets below to see which "recipe" gives the best correlation between these:
## LOD scores of mapped, raw REGR & tipAngle PC scores data
T4 <- function(s){
  # 
  # alpha = s[1:4]
  # beta = s[5:7] # specify this as "end of s" later
  
  # csv files for mapper() & in matrix format
  CT   <- read_cross2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/CvixLer.working.json")
  REGR <- read_csv("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/2021_04_18_growthCurveDescriptors_Averaged-FINAL.csv")
  tipAngle <- read_csv("~/Desktop/GravitropismAssay/TipAngle-Parameters-KinematicTraits_Data/2021-11-30_tipAngle_PCScores.csv")
  REGR = data.matrix(REGR)
  tipAngle = data.matrix(tipAngle)
  
  # Phenotype = REGR for 1st mapper
  CT$pheno <- REGR
  J = mapper(REGR, CT)

  # Phenotype = tipAngle for 2nd mapper
  CT$pheno <- tipAngle
  K = mapper(tipAngle, CT)
  
  # Find correlations between REGR & tipAngle LOD scores
  L = metric(J, K)
  L = as.vector(L)
  
  # # Add correlations
  # P = H + L
  # print(P)
}

recipe_T4 = fminsearch(T4, runif(7), minimize = FALSE, maxiter = 100)
pp = recipe_T4$xmin
optA = pp[1:4]
optB  = pp[5:7]

# Transform REGR & tipAngle data by the "recipe" from fminsearch()
CT <- read_cross2("~/Desktop/QTL_AnalysisMaterials/Ashley_QTL/CvixLer.working.json")
CT$pheno <- REGR
optAA  = mapper(predictor(REGR, optA), CT)
CT$pheno <- tipAngle
optBB  = mapper(predictor(tipAngle, optB), CT)

# Plot new LOD scores
x_axis = c(1:340)
row.names(optAA) <- c(1:340)
row.names(optBB) <- x_axis
data_T4 = data.frame(cbind(optAA, optBB))

ggplot(data_T4, aes(x = x_axis)) +
  geom_line(aes(y = maxREGR), colour = "blue") +
  geom_line(aes(y = posMaxREGR), colour = "cyan") +
  geom_line(aes(y = overallGrowthRate), colour = "cornflowerblue") +
  geom_line(aes(y = growthZoneWidth), colour = "aquamarine3") +
  
  geom_line(aes(y = RIL1.TipAngle_PC1), colour = "red") +
  geom_line(aes(y = RIL1.TipAngle_PC2), colour = "brown1") +
  geom_line(aes(y = RIL1.TipAngle_PC3), colour = "darkred") +

  # ADD A LINE SO WE KNOW WHAT'S SIGNIFICANT!!!

  xlab("Marker Locations along Genome") +
  ylab("LOD Score") +
  ggtitle("Transformed LOD Scores of Tip Angle PCs and REGR Traits Data") +
  theme_bw()
```

```{r testing-using-CCA}
# Can test if fminsearch went well by finding the true values of alpha and beta using Canonical Correlation Analysis
## Helpful site: https:// stats.idre.ucla.edu/r/dae/canonical-correlation-analysis/
library("CCA")
CCA = cc(REGR, tipAngle)

# Maximized coefficients from own code with fminsearch():
pp
optJ  = pp[1:4]
optK  = pp[5:7]
optJJ = optJ/norm(optJ, type = "2")
optKK = optK/norm(optK, type = "2")

# Maximized coefficients from CCA()
CCA$cor
CCA$scores$xscores[,1]
CCA$scores$yscores[,1]
cor(CCA$scores$xscores[,1], CCA$scores$yscores[,1]) # check that correlation matches my cca process' correlation
cor(CCA$scores$xscores[,2], CCA$scores$yscores[,2]) # this isn't great, so we'll just focus on the 1st column

optA = CCA$xcoef[,1]
optB = CCA$ycoef[,1]
optAA = optA/norm(optA, type = "2")
optBB = optB/norm(optB, type = "2")


# 18 Jan 2021
## Compared optJJ & optKK (my version of CCA) to make sure they match optAA & optBB (R version of CCA)
## They match! :)

```


```{r tipAngle-sweep}
# Will start 19 Jan 2021 with Nathan



```


