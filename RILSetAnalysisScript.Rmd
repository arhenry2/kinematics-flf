---
title: "RIL Set Analysis Script"
author: "Ashley Henry"
date: "4/9/2020"
output: html_document
---

```{r setup, include=FALSE}
### Gets flf package loaded into environment ###
# install.packages("backports")
# install.packages("rcmdcheck")
# install.packages("devtools")
# install.packages("rowr")
# install.packages("plotly")
# install.packages("naniar")
# setwd("/Users/ashleyhenry/")
devtools::load_all('/Users/ashleyhenry/flf')
library(flf)
library(ggplot2)
library(plotly)
library(tidyverse)
library(readr)
library(rowr)
require(reshape2)
library(dplyr)
library(naniar)
```

# Script to Analyze RIL Set
__Note:__ 

## Script Completions:
* Loads in all clicking data into a res structure (complicated list of lists)
* Combines all res structures into one workable dataframe
* Relabels data as simplified RIL name (not path/filename)
* Balances out sample size (currently at less than/equal to 8 replicates)
* Calculates log(k) and log(n)
* Calculates average, median, st dev, & variance of the parameters for each RIL

## Script to-dos:
* Repeatable & efficient outlier testing (one-by one version in AnalyzeKinematic[...].Rmd)
* Velocity curves (calcs pos & vel from parameters)
* Goodness of fit for flf curve (R^2, show flf on point cloud for each RIL)
* REGR curves (calc pos & REGR from parameters)
* 

```{r load-data, echo=FALSE}
### Below is copied from AnalyzeKinematicAnalysisToolOutput.Rmd
### Creates path with folder of folders, each with one rawData.csv file
### Loads in all of the rawData.csv files ###
# masterPath <- "/Users/ashleyhenry/Desktop/controlLer_outlierTests"
masterPath <- "/Users/ashleyhenry/Desktop/RILPop_fromClicking/"
# masterPath <- "/Users/ashleyhenry/Desktop/UnitTestMasterPath" # unit masterpath for sanity (11.19.2019)

res <- processMasterFolder(masterPath)

# Saves res structure (technically a "large list") to the working directory
## Saves data in a binary file
save(res, file = "res_2020-09-17_tmpLer.RData")

```

```{r Load_Res_Structure}
# Loads desired res structure into environment
load("~/rildata/2020_08_23_allresStructures.RData")
```

# Note: The following code chunks are copied from combineResStructures.Rmd, to have one Analysis Script instead of several scripts doing partial work

```{r Load-Res-Structures}
# Iteratively loads in all res structures from ~/rildata directory by:
## Loads RData file into new environment
## Then extracts res variable
loadRData <- function(fileName) {
  #loads an RData file, and returns it
  e1 = new.env()
  load(fileName, e1)
  get("res", e1)
}

# Load in correct res structure
load("~/rildata/res_CviLer_RILs1-10.RData")

# Pulls filenames from directory
fils <- matrix(list.files("~/rildata", pattern = "RData$", full.names = TRUE, recursive = TRUE))

# Loading them into RES structure
RES <- lapply(fils, loadRData)

# Save all that hard work, yeah
save(RES, file = "2020_09_16_allresStructures.RData")

load("~/rildata/2020_09_16_allresStructures.RData")

```

```{r Combine-Summary-Tables-of-Res-Structure}
############## function & for loop written on 30 January 2020 w/ Julian's help #############
####################### Copied from ParameterInvestigation.Rmd script ######################
# Function to separate res structure and rename pathname to filename for column "fileName" #
pathname_to_filename = function(genotype) {
  # Get genotype name from pathname
  genoName = basename(dirname(dirname(toString(genotype$fileName[[1]]))))
  # Create empty matrix of one column and as many rows as there are of res structure
  outnames = matrix(1, nrow(genotype))
  # Loops through each row of res
  ## Extracts pathname from each row in the dataframe
  ## Extracts filename from each pathname
  ## outnames = extracted filenames
  for (i in 1:nrow(genotype)) {
    namePlay_i  = toString(genotype$fileName[[i]])
    outnames[i] = basename(dirname(namePlay_i))
    print(outnames[i])
  }
  # Replaces pathname column with outnames column
  ## Now the column labeled "fileName" has filename instead of pathname
  genotype[["fileName"]] <- outnames
  # Return genotype summary table and genotype name
  gtype_gname = list(genotype, genoName)
  return(gtype_gname)
}

extractParameters = function(res) {
  # Create empty dataframe to fill with each RIL's parameters
  RILParameterSummaryTable = data.frame(matrix(
                                            ncol = 6, 
                                            nrow = 0, 
                                            dimnames = list(NULL, c("fileName", "x0", "vf", "k", "n", "mle"))))

  # for loop to call "pathname_to_filename" function for each genotype in res
  ## Fills dataframe with all replicates of all RILs' parameter summary tables
  for (i in 1:length(res)) {
    gtype = res[[i]]$summary_table
    gList = pathname_to_filename(gtype)
    summaryTable = gList[[1]]
    eval(parse(text = paste0(sprintf("%s = gList[[1]]", gList[[2]]))))
    RILParameterSummaryTable = rbind(RILParameterSummaryTable, summaryTable)
  }

  return(RILParameterSummaryTable)
}

# Uses function above to make summary table for parameters of all RILs
RILParams = lapply(RES, extractParameters)
RILParam_concatenated = bind_rows(RILParams)
# RILParam_concatenated = bind_rows(fileName) 

# Save progress
save(RILParam_concatenated, file = "2020_09_16_RILsSummaryParameters.csv")
```

```{r shorten-fileName-to-be-RILnumbers}
# This code chunk creates a new column called "RILs" and fills that column with the shortened fileName
## This allows the RILs to be grouped together and averaged, because now they have the same name to be grouped
## Note: Revised on 2020-05-27 to add leading zeros before RIL number

# Start with file you just created (^), need to load() then get() to have in environment
AllRILs_SummaryParameters = load("~/rildata/2020_09_16_RILsSummaryParameters.csv")
AllRILs_SummaryParameters = get(AllRILs_SummaryParameters)

# Makes a column of shortened RIL names by copying the fileName column
## Make copy of fileName column called RILs
AllRILs_SummaryParameters$RILs <- AllRILs_SummaryParameters$fileName

# Extracts the "RIL##" from fileName and fills in the "RILs" column
## This works for RILs, but need to correct for Cvi & Ler
AllRILs_SummaryParameters$RILs <- str_extract(AllRILs_SummaryParameters$RILs, "[A-Z]+[0-9]+")
AllRILs_SummaryParameters$RILs = str_extract(AllRILs_SummaryParameters$RILs, "[0-9]+")


#############################################################################################
######################## Use this chunk if need to add leading zeros ########################
############ Tried on 2020-05-27 & royally ruined everything for the QTLCode.R! #############
# Will try again, but will change genotype data to also have leading zeros, prevent more manual labor #
#############################################################################################
# # Extract only number from RIL##
# AllRILs_SummaryParameters$RILs <- str_extract(AllRILs_SummaryParameters$RILs, "[0-9]+")
# 
# # Make numbers numeric instead of characters to use sprintf()
# AllRILs_SummaryParameters$RILs <- as.numeric(AllRILs_SummaryParameters$RILs)
# # Use sprintf() to add "RIL_" leadingzeros to 3 digits "# of RIL"
# AllRILs_SummaryParameters$RILs <- sprintf("RIL%03d", AllRILs_SummaryParameters$RILs)
# ##### Note: This works for RIL numbers, but messes up with Cvi & Ler
# 
# # Replace RIL0NA with NA
# AllRILs_SummaryParameters$RILs <- str_replace(AllRILs_SummaryParameters$RILs, "RIL0NA", replacement = NA_character_)
#############################################################################################

# Filter out NAs from the dataframe's RILs column (which are Cvi & Ler)
## Using string split(), and "--" as the separator
## Makes that output into a matrix (to index in next line)
correctNAs = strsplit(AllRILs_SummaryParameters$fileName[is.na(AllRILs_SummaryParameters$RILs)], split = "--", fixed = TRUE)
correctNAs = matrix(unlist(correctNAs), nrow = length(correctNAs), byrow = T)

# Takes column from above output that contains "Cvi" and "Ler" (this time it's 2nd column, hence correctNAs[,2])
## Replaces the NAs with "Cvi" and "Ler" strings
AllRILs_SummaryParameters$RILs[is.na(AllRILs_SummaryParameters$RILs)] <- correctNAs[,2]

# Remove duplicates RILs 
## Because the 1st code chunk loads one extra res file (Cvi, Ler & RILs1-10)
AllRILs_SummaryParameters = AllRILs_SummaryParameters %>% 
  distinct()


# Save progress in csv file
write.csv(AllRILs_SummaryParameters, "~/rildata/2020_09_16_AllRILs_SummaryParameters.csv")
```

```{r sample-size-balancing}
##### This code chunk: Need to find RILs w/ 8+ samples & randomly reduce that to 8 #####

# Load in data saved from previous code chunk ^
# Problem: also loads in rownames as 1st column, fix this?
AllRILs_SummaryParameters = read.csv("~/rildata/2020_09_16_AllRILs_SummaryParameters.csv")



# Variable for threshold of replicate numbers, may be used later so code is dynamic
SAMPLETHRESH = 8
# Summary table subset that has column for RIL number and column for no. of replicates of that RIL no.
AllRILs_nParameters = AllRILs_SummaryParameters %>%
  group_by(RILs) %>%
  select(-X, -fileName) %>%
  tally() %>%
  filter(n >= SAMPLETHRESH)

# Function to make data subset of RILs that have >5 replicates
drawRILSamples = function(ril){

  # Takes in whole summary table of all RILs
  rilSample = AllRILs_SummaryParameters %>% 
    # Only filter out specified RIL replicates
    ## "ril" in this case is a list of RILs that have >5 replicates (RILs2Sample below)
    filter(RILs == ril)
  # saves the RILs that have >8 replicates in data subset called randSample
  randSample = sample_n(rilSample, SAMPLETHRESH)
  # function output is data subset in randSample
  return(randSample)
}

# Creates list of RILs that are in the AllRILs_nParameters that have >8 replicates
RILs2Sample = AllRILs_nParameters$RILs

# Uses drawRILSamples function to create data subset of randomly selected RILs from the list of RILs that contained >5 replicates
subsetwCorrectedSampleSize = lapply(RILs2Sample, drawRILSamples) # right data (maybe?), wrong format
# Fixed format of data subset with corrected replicate size
subsetwCorrectedSampleSize = bind_rows(subsetwCorrectedSampleSize) # Ta daaaa

# Now make separate dataframe containing only RILs with <=5 replicates
# Create list of RILs with okay relicate numbers
subsetwFineSamples = AllRILs_SummaryParameters %>%
  group_by(RILs) %>%
  select(-X, -fileName) %>%
  tally() %>%
  filter(n < SAMPLETHRESH)

# Create data subset only containing RILs with correct number of replicates
## Will be binded with subset of data that just corrected replicate number
subsetwFineSamples2 = AllRILs_SummaryParameters %>%
  subset(RILs %in% subsetwFineSamples$RILs)

# The final dataframe containing corrected number of replicates for each RIL
## Please rename~~~~~~
AllRILsCorrectedSampleSize = rbind(subsetwFineSamples2, subsetwCorrectedSampleSize) %>%
  group_by(RILs) %>%
  select(-X, -fileName)

# Save new dataset with corrected sample size (<= 5 samples) in csv file
write.csv(AllRILsCorrectedSampleSize, "~/rildata/2020_08_23_AllRILs_CorrectedSampleSize_SummaryParameters.csv")

```

```{r log(Parameter)-stats-by-RIL}
# This code chunk is to average parameters per RIL to create a table for the input of the R/qtl2 package
## Uses output from previous code chunk "shorten-fileName-to-be-RILnumbers"
# Info needed from RILs:
log() # take log() of all parameters to make data more normal
mean() # average of that RIL's parameter -> won't use this b/c have non-normal data
median() # median of that RIL's parameter -> WILL use this b/c have non-normal data
sd() # st dev of that RIL's parameter
var() # variance of that RIL's parameter
tally() # No. of samples for each RIL

# Load in csv with corrected sample size data
AllRILs_SummaryParameters = read.csv("~/rildata/2020_08_23_AllRILs_CorrectedSampleSize_SummaryParameters.csv")

# Take log of all parameters to produce more normal data
AllRILs_logParameters = AllRILs_SummaryParameters %>%
  # group_by(RILs) %>%
  select(-X, -fileName, -mle) %>%
  # log(a,b) b = base for log, else R will calc ln()
  mutate(logK = log(AllRILs_SummaryParameters$k, 10)) %>%
  mutate(logN = log(AllRILs_SummaryParameters$n, 10)) 

# Use summarise_each and funs() to calculate stats for all parameters
## Group by RIL to group together & get stats for each RIL (not taking stat of whole pop)
## Removed X (rownames created from csv) and fileName column from dataframe
## Calc'd chosen stat via summarise_each(funs())
AllRILs_AveragedParameters = AllRILs_logParameters %>% 
  mutate(RIL = as.numeric(RILs)) %>%
  group_by(RIL) %>% 
  # select(-X, -X.1, -fileName, -mle) %>%
  summarise_each(funs(mean))

AllRILs_MedianParameters = AllRILs_logParameters %>% 
  mutate(RIL = as.numeric(RILs)) %>%
  group_by(RILs) %>% 
  # select(-X, -X.1, -fileName, -mle) %>%
  summarise_each(funs(median))

AllRILs_StDevParameters = AllRILs_logParameters %>%
  mutate(RIL = as.numeric(RILs)) %>%
  group_by(RILs) %>%
  # select(-X, -X.1, -fileName, -mle) %>%
  summarise_each(funs(sd))

AllRILs_VarianceParameters = AllRILs_logParameters %>%
  mutate(RIL = as.numeric(RILs)) %>%
  group_by(RILs) %>%
  # select(-X, -X.1, -fileName, -mle) %>%
  summarise_each(funs(var))

AllRILs_nParameters = AllRILs_logParameters %>%
  mutate(RIL = as.numeric(RILs)) %>%
  group_by(RILs) %>%
  # select(-X, -X.1, -fileName, -mle) %>%
  tally()

# Save all files from above
write.csv(AllRILs_AveragedParameters, "~/rildata/2020_09_16_AllRILs_AveragedParameters.csv")
write.csv(AllRILs_MedianParameters, "~/rildata/2020_09_16_AllRILs_MedianParameters.csv")
write.csv(AllRILs_StDevParameters, "~/rildata/2020_08_23_AllRILs_StDevParameters.csv")
write.csv(AllRILs_VarianceParameters, "~/rildata/2020_08_23_AllRILs_VarianceParameters.csv")
write.csv(AllRILs_nParameters, "~/rildata/2020_08_23_AllRILs_nParameters.csv")
```

```{r brief-outlier-testing}
# install.packages("outliers")
library(outliers)
AllRILs_SummaryParameters = read.csv("~/rildata/2020_09_16_AllRILs_SummaryParameters.csv")

AllRILs_SummaryParameters = AllRILs_SummaryParameters %>%
  select(-X, -fileName) %>%
  group_by(RILs)

parametersMelted = melt(AllRILs_SummaryParameters, id.var = "RILs")

# Boxplot to Visualize parameter distribution
ggplot(data = parametersMelted, aes(x = variable, y = value)) + 
  geom_boxplot(aes(fill = variable)) +
  ylab("") +
  xlab("Parameters") +
  ggtitle("Distribution of Parameters") +
  theme_bw() +
  facet_wrap( ~ variable, scales = "free")



# Testing chisq test for whole xo column, now need to divide these up by RILs, and then by phenotype
chisq.out.test(AllRILs_SummaryParameters$x0, variance=var(AllRILs_SummaryParameters$x0), opposite = FALSE) #also run opposite = TRUE for highest value






```




```{r fittingVelCurves}
### Creates numeric vector for means of the parameters ###
### Makes range of y from 0.0 to 3.5 px/hr ###
### pos values range from 0-2000 px from QC, increasing by 1 px at a time ###
ku         <- vector('numeric')
range_of_y <- range(0, 3.5)
pos        <- seq(0, 2000, 1)

```

```{r EvaluateVelandREGRFits}
# Note: This code chunk is copied from AnalyzeKinematic[...].Rmd
# Loops through all genotypes/conditions evaluating the equation at a 
## value, Pos (fixed position values (0-2000, increments of 1)), to 
## calculate velocity and REGR values using the maximum likelihood 
## estimate parameters for each replicate
# WARNING: Fits ALL replicates, not the average. To fit the avg vel, 
## look to the next code chunk
# Please Note: The final product has the correct units (hallelujah!)

for (i in 1:length(res)) {
  resultVel <- evaluateVelFits(res[[i]], pos)
  matrixEnd = ncol(resultVel) - 1
  for (j in 2:matrixEnd) {
    resultVel[,j] <- as.numeric(resultVel[,j]) * 0.08202 } # conversion from px/frame to mm/hr for all velocity value columns
  resultVel[,1] = as.numeric(resultVel[,1]) / 1463 # conversion from px to mm for the one position value column
  write.csv(resultVel, paste('/Users/ashleyhenry/Desktop/PosEvaluatedVel', as.numeric(i), '.csv', sep = ""), row.names = F)
  plot(resultVel[,1], resultVel[,2])
  
  ######################################
  
  resultREGR <- evaluateREGRFits(res[[i]], pos, 120*100)
  matrixEnd = ncol(resultREGR) - 1
  
  # for (k in 2:matrixEnd) {
    # resultREGR[,j] <- as.numeric(resultREGR[,j]) * 120} # DOESN'T WORK: conversion from px/frame*frame to px/frame*hr (or %/hr) for all velocity value columns
  
  resultREGR[,1] = as.numeric(resultREGR[,1]) / 1463 # WORKS: conversion from px to mm for the one position value column
  write.csv(resultREGR, paste('/Users/ashleyhenry/Desktop/PosEvaluatedREGR', as.numeric(i), '.csv', sep = ""), row.names = F)
  plot(resultREGR[,1], resultREGR[,2])
}
```



